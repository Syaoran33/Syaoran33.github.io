[{"title":"Index 导航","url":"/2023/06/18/index/","content":"欢迎来到我的博客Awesome begin~\n\n\n\n\nPython文档官方Python: python官方文档difflib: 计算差异的辅助工具Typing: 类型注解支持\n常用APScheduler: 计划任务定时的运行、管理及调度Pandas: 数据分析处理工具XlsxWriter: 电子表格写入格式\n管理Pydantic: 使用python类型注释进行数据验证和配置管理Poetry: Python虚拟环境、依赖管理及打包发布loguru: 简洁优雅的日志工具\n网络Httpx: Python3的全功能HTTP客户端，提供网络请求协程支持和异步APIPyCryptodome: 加密模块Fastapi: 用于构建 API 的现代、快速（高性能）的 web 框架\n数据库pymongo: Pymongo库文档peewee: 轻量级ORM库，提供简单的API以进行SQLite操作，还支持其他数据库TinyDB: Python轻量级数据库\n\n常用Quick Reference: 代码速查表MongoDB: MongoDB官方文档\n\n文章Python包管理之poetry的使用pandas对账逆向卸载ASM系统卸载ASMRustdesk中继服务器\n\n镜像Tuna: 清华镜像站Taobao: 阿里镜像站moeyy: 萌羽自建\n","categories":["Notes"],"tags":["Small talk"]},{"title":"Python爬虫技巧-异步请求装饰器","url":"/2022/10/13/tutorial/python_spider/python_spider02/","content":"爬虫请求时,可以将请求体等信息作为静态信息,通过定义装饰器来请求响应及除错\n \n\n\n\n\n常规import httpx# Decorator def request(func):    def wrapper(*arg, **kwarg):        req = func(*arg, **kwarg)        client = httpx.Client()        ret = client.send(req)        return ret    return wrapper@requestdef getUsers(method, url, params):    return httpx.Request(method, url, params=params)data = getUsers(&#x27;GET&#x27;, &#x27;http://host:port/getUsers&#x27;,&#123;&#x27;user_query&#x27;: &#x27;username&#x27;&#125;)print(data.text)\n\n\n协程通过协程来使用装饰器时,需要额外借助functools来对异步函数进行装饰\nimport httpximport asyncioimport functoolsdef asyncRequest(client):    def inner(func):        @functools.wraps(func)        async def wrapper(*arg,**kwarg):            req = func(*arg, **kwarg)            ret = await client.send(req)            return ret                return wrapper    return innerclient = httpx.AsyncClient()@asyncRequest(client)def asyncGetUsers(method, url, params):    return httpx.Request(method, url, params=params)data = asyncio.run(getUsers(&#x27;GET&#x27;, &#x27;http://host:port/getUsers&#x27;,&#123;&#x27;user_query&#x27;: &#x27;username&#x27;&#125;))print(data.text)\n","categories":["Tutorials"],"tags":["Python","Spider","Asyncio"]},{"title":"实用教程-VSCode设置用户代码片段","url":"/2022/08/21/tutorial/diy/vscode-user-script/","content":"配置模板，通过键入命令自动生成代码片段，提高写代码效率\n\n\n基础\n官方文档\n在线生成工具\n通过输入Insert Snippet查看代码片段命令\n在插件中搜索安装社区代码片段@category:&quot;snippets&quot;\n\n代码片段配置setting.json >folded&quot;[markdown]&quot;: &#123;    &quot;editor.formatOnSave&quot;: true,    &quot;editor.renderWhitespace&quot;: &quot;all&quot;,    &quot;editor.quickSuggestions&quot;: &#123;        &quot;other&quot;: true,        &quot;comments&quot;: true,        &quot;strings&quot;: true    &#125;,    &quot;editor.acceptSuggestionOnEnter&quot;: &quot;on&quot;&#125;\n\nMarkDown&#123;    &quot;more&quot;: &#123;\t\t&quot;prefix&quot;: &quot;more&quot;,\t\t&quot;body&quot;: [\t\t\t&quot;&lt;!-- more --&gt;&quot;\t\t],\t\t&quot;description&quot;: &quot;阅读全文&quot;\t&#125;&#125;\n"},{"title":"Python爬虫技巧-Pica接口签名加密分析","url":"/2021/03/19/tutorial/python_spider/python_spider01/","content":"接口签名加密，某小粉书app接口加密方法分析\n\n \n\n\n*申明：\n在此申明，仅作为非商业用途的学习交流和个人记录用途，请严格遵守相关国家规定\n\n逛Github发现一个各种平台自动打卡的项目\n研究发现了一个接口签名加密，然后对某粉色app接口加密方法进行分析\n看完突然想到，上次版本更新以后加了一些随机数和时间戳等参数\n好像和K7大佬说的万象物语数据包加密有点相似。用的参数类似，具体方法应该不同\n依赖python包pip install httpx\n\n代理配置一个代理\n加密方式分析用代理工具(BurpSuite)分析了几个数据包\n发现头部(headers)有三个变化的参数\ntime、nonce、signature\n\ntime看的出来就是时间戳\n生成方法\nimport timetime.time()\n\nnonce32位的字母数字混合字符串\n后面几位没有变化，可能是uuid\n然后看项目代码，果然是uuid\n这里使用随机数的uuid4伪造\n后来发现，任意32位英文数字字符串也可以\n生成方法\nimport uuiduuid.uuid4()\n\nsignature参考源项目代码，使用了hmac_sha256的方式\n消息是使用多因素的验证\nformater = path + timestamp + uuid + method + api_key\n\n请求地址，时间戳，随机数，请求方法，API密钥\n生成方法\nformater = path + time + nonce + method + api_keymsg = formater.lower().encode()encrypter = hmac.new(key, msg, digestmod=hashlib.sha256)signature = encrypter.hexdigest()\n\n完整代码#!/usr/bin/env python# -*- encoding: utf-8 -*-import uuidimport timeimport hmacimport hashlibimport base64import httpximport jsonclass PICACG:    api_key = &#x27;C69BAF41DA5ABD1FFEDC6D2FEA56B&#x27;    secret_key = &#x27;fmR9JFE3JGVJbmk9Vik5XFJLL1AuUk00OzlbN3xAL0NBfWJ+T1chMz9FVmA6PD5NN3BkZFVCTDVufDAvKkNu&#x27;    base_url = &#x27;https://picaapi.picacomic.com/&#x27;    headers = &#123;        &#x27;user-agent&#x27;: &#x27;okhttp/3.8.1&#x27;,        &#x27;Accept-Encoding&#x27;: &#x27;gzip, deflate&#x27;,        &#x27;accept&#x27;: &#x27;application/vnd.picacomic.com.v1+json&#x27;,        &#x27;api-key&#x27;: api_key,        &#x27;app-channel&#x27;: &#x27;3&#x27;,        &#x27;app-uuid&#x27;: &#x27;defaultUuid&#x27;,        &#x27;app-version&#x27;: &#x27;2.2.1.3.3.4&#x27;,        &#x27;image-quality&#x27;: &#x27;original&#x27;,        &#x27;app-platform&#x27;: &#x27;android&#x27;,        &#x27;app-build-version&#x27;: &#x27;45&#x27;,        &#x27;Host&#x27;: &#x27;picaapi.picacomic.com&#x27;,        &#x27;Content-Type&#x27;: &#x27;application/json; charset=UTF-8&#x27;, #&#x27;application/x-www-form-urlencoded&#x27;    &#125;    @staticmethod    def _proxy(proxy):        if isinstance(proxy, dict):            proxies = proxy        elif proxy == &#x27;Clash&#x27;:            proxies = &#123;                &#x27;http&#x27;: &#x27;http://localhost:7890&#x27;,                &#x27;https&#x27;: &#x27;http://localhost:7890&#x27;,            &#125;        elif proxy == &#x27;BurpSuite&#x27;:            proxies = &#123;                &#x27;http&#x27;: &#x27;http://localhost:8080&#x27;,                &#x27;https&#x27;: &#x27;http://localhost:8080&#x27;,            &#125;        else:            proxies = &#123;&#125;        return proxies    def __init__(self, proxy=False):        self.client = httpx.Client(            base_url=self.base_url, proxies=self._proxy(proxy))    @staticmethod    def _nonce() -&gt; str:        nonce = uuid.uuid4().hex        return nonce    @staticmethod    def _timestamp() -&gt; str:        timestamp = time.time()        return str(int(timestamp))    def _signature(self, path, method) -&gt; dict:        &quot;&quot;&quot;Signature encrypter&quot;&quot;&quot;        time = self._timestamp()        nonce = self._nonce()        api_key = self.api_key        key = base64.b64decode(self.secret_key.encode())        formater = path + time + nonce + method + api_key        msg = formater.lower().encode()        encrypter = hmac.new(key, msg, digestmod=hashlib.sha256)        signature = encrypter.hexdigest()        varibals = &#123;            &#x27;time&#x27;: time,            &#x27;nonce&#x27;: nonce,            &#x27;signature&#x27;: signature        &#125;        headers = self.headers.copy()        headers.update(varibals)        return headers    def login(self, uid: str, pwd: str):        url = &#x27;auth/sign-in&#x27;        method = &#x27;POST&#x27;        headers = self._signature(url, method)        data = &#123;            &#x27;email&#x27;: uid,            &#x27;password&#x27;: pwd        &#125;        res = self.client.post(url=url, headers=headers, data=json.dumps(data))        print(res.json())        token = res.json()[&#x27;data&#x27;].get(&#x27;token&#x27;)        return tokenpica = PICACG(proxy= &#x27;Clash&#x27;)token = pica.login(&#x27;uid&#x27;,&#x27;pwd&#x27;)\n\n爬虫知识通过这种加密方式，可以提高安全性\n防止接口被爬虫攻击和滥用\n对于游戏而言，通过添加随机字符串，时间戳等参数\n可以较为有效的防止重放攻击和数据被恶意修改\n","categories":["Tutorials"],"tags":["Python","Spider","Crypto","NSFW"]},{"title":"从零开始的手游解包教程-批量解包篇(六)","url":"/2021/03/11/tutorial/sdorica/gamedata_reverse06/","content":"本篇介绍使用脚本进行批量的分类解包\n \n\n\n*申明：\n在此申明，仅作为非商业用途的学习交流和个人记录用途，请严格遵守游戏用户协定，勿将提取的游戏资源发布到任何第三方平台。\n否则将可能造成游戏公司切实的利益损失，与一些不必要的麻烦甚者需承担相应的法律责任\n本篇不授权并禁止任何目的的分享、转载和引用，望理解\n\n介绍本篇介绍使用脚本进行批量的分类解包\n不出意料这样该是解包教程的最后一篇了，相信看完这篇你将成为一名解包大佬\n鼓掌👏\n优势\n批量解包，提升效率\n解包后文件按原路径提取和分类，便于查看\n指定类型，获取对应类型文件\n\n操作方法依赖pip install UnityPy\n\n代码# Sdorica_ABC.pyimport osfrom UnityPy import AssetsManagerfrom collections import Counterimport zipfileimport logginglogging.basicConfig(level=logging.ERROR,format=&#x27;%(message)s&#x27;)TYPES = [&#x27;TextAsset&#x27;, &#x27;Sprite&#x27;, &#x27;Texture2D&#x27;]ROOT = os.path.dirname(os.path.realpath(__file__))# source folderASSETS = os.path.join(ROOT, &#x27;AssetBundles&#x27;)# destination folderDST = os.path.join(ROOT, &#x27;textasset&#x27;)# number of dirs to ignore# e.g. IGNOR_DIR_COUNT = 2 will reduce# &#x27;assets/assetbundles/images/story_picture/small/15.png&#x27;# to# &#x27;images/story_picture/small/15.png&#x27;IGNOR_DIR_COUNT = 0os.makedirs(DST, exist_ok=True)def main():\tfor root, dirs, files in os.walk(ASSETS):\t\tdel dirs\t\tfor f in files:\t\t\t#print(f)\t\t\tsrc = os.path.realpath(os.path.join(root, f))\t\t\ttry:\t\t\t\textract_assets(src)\t\t\texcept:\t\t\t\tpassdef extract_assets(src):\t# load source\tam = AssetsManager(src)\t# iterate over assets\tfor asset in am.assets.values():\t\t# assets without container / internal path will be ignored for now\t\tif not asset.container:\t\t\tcontinue\t\t# check which mode we will have to use\t\tnum_cont = sum(1 for obj in asset.container.values() if obj.type in TYPES)\t\tnum_objs = sum(1 for obj in asset.objects.values() if obj.type in TYPES)\t\t# check if container contains all important assets, if yes, just ignore the container\t\tif num_objs &lt;= num_cont * 2:\t\t\tfor asset_path, obj in asset.container.items():\t\t\t\tfp = os.path.join(DST, *asset_path.split(&#x27;/&#x27;)[IGNOR_DIR_COUNT:])\t\t\t\texport_obj(obj, fp)\t\t# otherwise use the container to generate a path for the normal objects\t\telse:\t\t\textracted = []\t\t\t# find the most common path\t\t\toccurence_count = Counter(os.path.splitext(asset_path)[0] for asset_path in asset.container.keys())\t\t\tlocal_path = os.path.join(DST, *occurence_count.most_common(1)[0][0].split(&#x27;/&#x27;)[IGNOR_DIR_COUNT:])\t\t\tfor obj in asset.objects.values():\t\t\t\tif obj.path_id not in extracted:\t\t\t\t\textracted.extend(export_obj(obj, local_path, append_name=True))def export_obj(obj, fp: str, append_name: bool = False) -&gt; list:\tif obj.type not in TYPES:\t\treturn []\tdata = obj.read()\tif append_name:\t\tfp = os.path.join(fp, data.name)\tfp, extension = os.path.splitext(fp)\tos.makedirs(os.path.dirname(fp), exist_ok=True)\tif obj.type == &#x27;TextAsset&#x27;:\t\tif not extension:\t\t\textension = &#x27;.txt&#x27;\t\twith open(f&quot;&#123;fp&#125;&#123;extension&#125;&quot;, &#x27;wb&#x27;) as f:\t\t\tf.write(data.script)\telif obj.type == &#x27;MonoBehaviour&#x27;:\t\textension = &#x27;.txt&#x27;\t\tmetadata =data.type_tree[&#x27;_serializedStateValues&#x27;][0]\t\twith open(f&quot;&#123;fp&#125;&#123;extension&#125;&quot;, &#x27;w&#x27;) as f:\t\t\tf.write(metadata)\telif obj.type == &quot;Sprite&quot;:\t\textension = &quot;.png&quot;\t\tdata.image.save(f&quot;&#123;fp&#125;&#123;extension&#125;&quot;)\t\treturn [obj.path_id, data.m_RD.texture.path_id, getattr(data.m_RD.alphaTexture, &#x27;path_id&#x27;, None)]\telif obj.type == &quot;Texture2D&quot;:\t\textension = &quot;.png&quot;\t\tfp = f&quot;&#123;fp&#125;&#123;extension&#125;&quot;\t\tif not os.path.exists(fp):\t\t\ttry:\t\t\t\tdata.image.save(fp)\t\t\texcept EOFError:\t\t\t\tpass\telif obj.type == &#x27;AudioClip&#x27;:\t\tif not extension:\t\t\textension = &#x27;.wav&#x27;\t\ttry:\t\t\tsamples = data.samples\t\t\tfor item in samples:\t\t\t\taudio = samples.get(item).obj\t\t\twith open(f&quot;&#123;fp&#125;&#123;extension&#125;&quot;, &#x27;wb&#x27;) as f:\t\t\t\tf.write(audio)\t\texcept Exception as error:\t\t\tlogging.error(error)\t\t\tpass\treturn [obj.path_id]if __name__ == &#x27;__main__&#x27;:\tmain()\n\n类型TYPES = [&#x27;TextAsset&#x27;, &#x27;Sprite&#x27;, &#x27;Texture2D&#x27;]\n\n修改上面的内容，进行添加或限制进行解包\n文件夹路径# source folderASSETS = os.path.join(ROOT, &#x27;AssetBundles&#x27;)# destination folderDST = os.path.join(ROOT, &#x27;textasset&#x27;)\n\nASSETS为输入文件夹，就是存放.ab文件的文件夹\nDST为输出文件夹，输出解包后的文件\n额外依赖在对AudioClip解包时需要额外的依赖文件\nlibogg.dlllibvorbis.dll\n\n可以在github上搜索后下载，置于.py脚本的同级目录\n使用方法python Sdorica_ABC.py \n\n优化\n使用脚本可能会导致解包文件被重复替换\n由于电脑性能限制本例未使用多线程，可自行添加多线程提升解包速度\n未对文件作筛选过滤，可以通过if判断限制想要解包的内容\n\n结语至此，已经基本结束了对万象物语的游戏解包教程，难度较大的内容已经被我省去，基本上有一台能正常使用的Windows电脑即可操作\n还请记住，不要将解包获取到的游戏资源上传、分享到其他第三方，谢谢合作\n","categories":["Tutorials"],"tags":["Sdorica","Mobile games","Reverse engineering"]},{"title":"从零开始的手游解包教程-文本资源篇(五)","url":"/2021/03/10/tutorial/sdorica/gamedata_reverse05/","content":"本篇介绍如何解包相关文本资源使用脚本对16进制数据文件进行反序列化的处理\n \n\n\n*申明：\n在此申明，仅作为非商业用途的学习交流和个人记录用途，请严格遵守游戏用户协定，勿将提取的游戏资源发布到任何第三方平台。\n否则将可能造成游戏公司切实的利益损失，与一些不必要的麻烦甚者需承担相应的法律责任\n本篇不授权并禁止任何目的的分享、转载和引用，望理解\n\n介绍本篇介绍如何解包相关文本资源\n使用脚本对16进制数据文件进行反序列化的处理\n通过本篇的学习，也可以为普吉机器人的开发提供更加便利的数据支持\n引入在游戏资料根目录里有一个imperium/文件夹\n其中的文件就存放了游戏的相关文本资源，其中包括但不仅限于\n角色名称、技能名称、技能组资料等\n分析将imperium/localization/文件夹下的文件复制到电脑\n\n使用Hex编辑器打开检查,这里使用HxD编辑器\n\n发现不是单纯的二进制，用python读一下\n\n果然是对一部分数据进行了特殊的序列化，部分文本正常\n这种特殊的处理，让我立即联想到一种数据格式pickle\n但很明显手游不可能使用python的存储格式\n所以我立即在谷歌上搜素了一下Java的序列化方法\n终于，在不懈的努力下我总算找到了序列化的方法—MessagePack\n解包方法安装依赖pip install u-msgpack-python\n\n解包t = open(file_path,&#x27;rb&#x27;).read()data =umsgpack.unpackb(t)\n\n完整代码# unpack.pyimport umsgpackimport jsonimport sys file_path = sys.argv[1]file_name = sys.argv[2]t = open(file_path,&#x27;rb&#x27;).read()data =umsgpack.unpackb(t)with open(file_name+&#x27;.json&#x27;,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;) as f:    f.write(json.dumps(data,ensure_ascii=False))    f.close()\n\n用法python unpack.py fa05c23a-ecb7-4743-a719-bb4f5a0eaf38 localization\n\n生成一个localization.json的文件\n\n引申其他文件的解包方法类似，gamedata文件中也有很多重要的资料\n普吉机器人技能组文件介绍使用脚本生成技能组文件并编码\n代码创建skillInfo.py文件\n#!/usr/bin/env python# -*- encoding: utf-8 -*-import jsonimport base64data = json.load(open(&#x27;localization.json&#x27;,&#x27;r&#x27;,encoding=&#x27;utf-8&#x27;))MetagameSkillInfo = data[&quot;C&quot;][&quot;MetagameSkillInfo&quot;][&quot;D&quot;]skillDict = &#123;&#125;for skillInfo in MetagameSkillInfo:    metaDict = &#123;        skillInfo[5]: skillInfo[2]    &#125;    skillDict.update(metaDict)metaBytes = base64.b64encode(json.dumps(skillDict,ensure_ascii=False).encode())with open(&#x27;skillInfo&#x27;,&#x27;wb&#x27;) as f:    f.write(metaBytes)    f.close()\n\n使用方法首先，用上述方法，将更新后的localization文件解包获取localization.json\n然后，把文件skillInfo.py和localization.json复制在同目录下\n使用如下命令即可\npython skillInfo.py\n\n最后，替换普吉机器人的资源文件，重启使用\n","categories":["Tutorials"],"tags":["Sdorica","Mobile games","Reverse engineering"]},{"title":"2021新年快乐","url":"/2021/02/12/notes/happy_new_year_2021/","content":"\n\n\n\n\n🧨新春快乐🎉牛年大吉🐮牛年快乐 Happy Chinese New Year !\n今年很多国际新闻的报道，都把Lunar改成Chinese，这是一件好事\n紧跟时事 雷亚你可长点心吧~\n\n","categories":["Notes"],"tags":["Small talk"]},{"title":"从零开始的手游解包教程-角色资源篇(四)","url":"/2021/02/08/tutorial/sdorica/gamedata_reverse04/","content":"前面介绍了如何对各种资源的解包，里面提到了角色的资源编号本篇介绍相关角色编号的特征和对应名称的解释\n \n\n\n*申明：\n在此申明，仅作为非商业用途的学习交流和个人记录用途，请严格遵守游戏用户协定，勿将提取的游戏资源发布到任何第三方平台。\n否则将可能造成游戏公司切实的利益损失，与一些不必要的麻烦甚者需承担相应的法律责任\n本篇不授权并禁止任何目的的分享、转载和引用，望理解\n\n*注: 本篇所有术语非官方，部分名词术语是根据英文语义进行翻译和实际应用进行总结的相关释义和备注的准确性有待商榷，其功用和大致意思会因本人的习惯比较主观的体现\n资源编号简介资源编号(AssetsId)是为了编程为了方便区分角色的一种编号。对于开发者比较友好，可以通过其编号特征对编号索引，快速找到指定某一角色，及其各阶角色、技能书等\n例如：h0030s5(琉 三阶), b0037s4(普吉 二阶)，h0097s5_a3(诺瓦 造型书)\n编号特征以诺瓦为例\nh      0097      s      5      _a3种族   序号      所属    阶级   技能书\\造型书\n\n种族\n*注：雷亚对于种族分类的界定不是特别的严谨，部分角色和其对应的种族存在些许差异\n\n\n\n\n缩写\n推测原缩写\n释义\n举例\n\n\n\nh\nhuman\n人类、亚种人类(亚人)\n希欧、猫眼、琉\n\n\nt\n-\n兽人、有尾种族\n庞、洛、杨波\n\n\nb\nbeast\n野兽\n古鲁瓦德、普吉\n\n\nr\nrobot\n机械、机巧\n玛莉亚、夏洛克\n\n\ne\n-\n-\n荷丝缇雅、蔓朵菈\n\n\nm\nmonster\n魔物、怪兽\n实验体\n\n\nn\n-\n-\n啾啾、猫头鹰号\n\n\n所属\n\n\n缩写\n推测原缩写\n释义\n\n\n\ns\nstorybook\n魂册\n\n\nc\ncommon\n通用、剧情\n\n\n阶级\n*注：部分情况剧情角色不守该阶级限制\n\n\n\n\n编号\n对应颜色\n对应阶级\n\n\n\ns2\n灰色\n-\n\n\ns3\n蓝色\n一阶\n\n\ns4\n紫色\n二阶\n\n\ns5\n金色\n三阶\n\n\n技能书\\造型书\n*注：通常情况下，造型书&#x2F;技能书都是以三阶角色为原型。\n少部分如蒂卡-冬青少女，是以二阶为原型制作，其编号也会因此改变h0010s4_a3\n\n\n\n\n编号\n类型\n\n\n\n_a2\n技能书\n\n\n_a3\n造型书1\n\n\n_a4\n造型书2\n\n\n*.bson文件Bson按字面意思就是(Binary Json)，一种二进制的数据格式。\n广泛(并不)用于MongoDB数据库的数据格式，在万象中bson文件也是为了压缩文件和序列化而被使用，例子就是charAssets.bson(老版本,3.2更新以前)\n使用python读写安装pip install bson\n\n如果安装过pymongo库，请先卸载后再安装。否则会库的路径不对导致模块引入报错\npip uninstall pymongopip install bson\n\n读取import bsonf = open(&#x27;metadata.bson&#x27;,&#x27;rb&#x27;)data = bson.loads(f)\n\n写入import bsondata = bson.dumps()\n\ncharAssets.bson\n*注：现版本已经失效\n\n万象物语角色技能组配置文件，包含所有角色的技能、buff等配置\n角色技能的释放都依赖于该文件，理论上对此文件进行修改可直接影响游戏内技能效果和倍率等\n解码方式使用python脚本\n#!/usr/bin/env python# -*- encoding: utf-8 -*-# Author: Syaoran at Sdorica.devimport jsonimport bsonimport base64bson_file = open(&#x27;charAssets.bson&#x27;,&#x27;rb&#x27;)bson_file = base64.b64decode(bson_file.read())bson_data = bson.loads(bson_file)def replace():\traw = json.dumps(bson_data) #raw\traw = raw.replace(&#x27;\\\\&#x27;,&#x27;&#x27;) #replace \\\traw = raw.replace(&#x27;&quot;: &quot;&#123;&quot;&#x27;,&#x27;&quot;: &#123;&quot;&#x27;) #replace front &quot;\traw = raw.replace(&#x27;&quot;&#125;&quot;,&#x27;,&#x27;&quot;&#125;,&#x27;) #replace back &quot;\traw = raw.replace(&#x27;&quot;&#125;&quot;&#125;,&#x27;,&#x27;&quot;&#125;&#125;,&#x27;).replace(&#x27;&#125;&quot;&#125;&#125;&#x27;,&#x27;&#125;&#125;&#125;&#x27;) #replace special &quot;\traw = raw.replace(&#x27;&quot;:.&#x27;,&#x27;&quot;:0.&#x27;).replace(&#x27;&quot;:-.&#x27;,&#x27;&quot;:-0.&#x27;) #add 0.\treturn rawraw = replace()with open(&#x27;charAssets.json&#x27;,&#x27;w&#x27;) as f:\tf.write(raw)\n\nCharAssets.zip新版本更新后采用这种方式来存放技能组配置文件。但是相较于之前，更加容易解包\n解压首先看后缀就知道是压缩文件格式(.zip)\n分析bson起初我以为还是和之前一样是b64编码的bson文件，试了很长时间都没成功。\n后来直接读二进制，发现能看到部分内容，猜想应该是某种序列化。又试了一段时间，还是没有完美还原\n后来看到文件大小突然醒悟，30M的内容变成5M，肯定是采用了压缩格式。所以我就用压缩软件测试，发现果然是压缩文档。随后确定就是gunzip()\n综上，只需要使用两次解压即可获取数据，bson完全是糊弄人的\n解包压缩完成后即是json数据格式，无需其他处理\n使用python脚本自动化#!/usr/bin/env python# -*- encoding: utf-8 -*-import gzipimport zipfileimport osclass zippy:    def unzip(self,bundle_path,dir_path):        &quot;&quot;&quot;解压CharAsset.zip\\n        :param bundle_path: 压缩包地址\\n        :param dir_path: 解压路径文件夹&quot;&quot;&quot;        zip_file = zipfile.ZipFile(bundle_path)        zip_ls = zip_file.namelist()        for f in zip_ls:            zip_file.extract(f, dir_path)        zip_file.close()    def bson2json(self,bundle_path,dir_path,dst_path):        &quot;&quot;&quot;批量转换bson文件为json文件\\n        :param bundle_path: 压缩包地址\\n        :param dir_path: 解压路径文件夹\\n        :param dst_path: json文件输出路径文件夹        &quot;&quot;&quot;        if os.path.isfile(os.path.join(dir_path,&#x27;Manifest.bson&#x27;)) != True:            self.unzip(bundle_path,dir_path)        for root,dirs,files in os.walk(dir_path):            for file_name in files:                file_path = os.path.join(root,file_name)                data = gzip.GzipFile(file_path,&#x27;rb&#x27;).read().decode()                if os.path.isdir(dst_path) != True:                    os.mkdir(dst_path)                if os.path.isfile(os.path.join(dst_path,&#x27;Manifest.json&#x27;)) != True:                    with open(os.path.join(dst_path,file_name).replace(&#x27;bson&#x27;,&#x27;json&#x27;),&#x27;w&#x27;,encoding=&#x27;utf8&#x27;) as f:                        f.write(data)                        f.close()        del dirs\n\n更加安全高效在后续研究中发现，使用这种方式：\n\n一是可以降低占用的内存，只有在加载进关卡时才会根据所需角色释放压缩文件\n二是额外添加了Manifest文件作为数据的质检员，对各项文件进行了哈希处理并做了不可逆的加密，较为有效的防止了数据的篡改\n\n模板BattleCharacter&#123;    &quot;AssetsId&quot;:&#123;        &quot;_power&quot;: 0,        &quot;_armorCapacity&quot;: 0,        &quot;_bloodCapacity&quot;: 0,        &quot;_passiveBuff&quot;: &#123;            &quot;$content&quot;: []        &#125;,        &quot;_levelStartBuff&quot;: &#123;            &quot;$content&quot;: []        &#125;,        &quot;_characterAI&quot;: &#123;            &quot;OrderList&quot;: &#123;                &quot;$content&quot;: []            &#125;,            &quot;$type&quot;: &quot;BattleModel.SequenceEnemyAI&quot;        &#125;,        &quot;_stoneEraseSetting&quot;: &#123;            &quot;$content&quot;: [                &#123;                    &quot;Key&quot;: 0,                    &quot;Value&quot;: &quot;S1&quot;                &#125;,                &#123;                    &quot;Key&quot;: 1,                    &quot;Value&quot;: &quot;S2&quot;                &#125;,                &#123;                    &quot;Key&quot;: 2,                    &quot;Value&quot;: &quot;S3&quot;                &#125;            ]        &#125;,        &quot;_skillsetTable&quot;: &#123;&#125;,        &quot;_skills&quot;: &#123;&#125;,        &quot;_reviveCount&quot;: 0,        &quot;_stoneType&quot;: 0,        &quot;_assistantSkill&quot;: null,        &quot;_initialCoolDown&quot;: 0,        &quot;_defaultCoolDown&quot;: 0,        &quot;_masterRank&quot;: 0,        &quot;_mass&quot;: 1,        &quot;_pose&quot;: &quot;Stand&quot;,        &quot;ReferenceCharacterKeys&quot;: &#123;            &quot;$content&quot;: []        &#125;,        &quot;ReferenceEffectKeys&quot;: &#123;            &quot;$content&quot;: []        &#125;,        &quot;ReferenceBuffKeys&quot;: &#123;            &quot;$content&quot;: []        &#125;,        &quot;ReferenceSFXKeys&quot;: &#123;            &quot;$content&quot;: []        &#125;,        &quot;ReferenceVoiceSFXKeys&quot;: &#123;            &quot;$content&quot;: []        &#125;,        &quot;ReferenceMusicKeys&quot;: &#123;            &quot;$content&quot;: []        &#125;,        &quot;ReferenceEmoIconKeys&quot;: &#123;            &quot;$content&quot;: []        &#125;,        &quot;$type&quot;: &quot;BattleModel.SummonSlot&quot;    &#125;&#125;\n\n键值参数\n\n\n键\n释义\n角色备注\n\n\n\nAssetsId\n资产编号&#x2F;名称\nb0037s5\n\n\n_power\n基础攻击力\n\n\n\n_bloodCapacity\n基础血量\n\n\n\n_armorCapacity\n基础护盾值\n\n\n\n_passiveBuff\n被动buff\n\n\n\n_levelStartBuff\n- (阶段开始效果)\n\n\n\n_characterAI\n- (角色AI)\n\n\n\n_characterAI.OrderList\n- (技能顺序)\n\n\n\n_stoneEraseSetting\n技能魂芯消除设定\n\n\n\n","categories":["Tutorials"],"tags":["Sdorica","Mobile games","Reverse engineering"]},{"title":"Spine动画模型教程-Chibi在线工具使用(三)","url":"/2020/12/27/tutorial/sdorica/spine_anime03/","content":"本篇讲解如何使用一个非常nice的网页在线工具\n可以用于模型的查看，以及导出gif&#x2F;png图片\n \n\n\n*申明：\n在此申明，仅作为非商业用途的学习交流和个人记录用途，请严格遵守游戏用户协定，勿将提取的游戏资源发布到任何第三方平台。\n否则将可能造成游戏公司切实的利益损失，与一些不必要的麻烦甚者需承担相应的法律责任\n本篇不授权并禁止任何目的的分享、转载和引用，望理解\n\n介绍本篇讲解如何使用一个非常nice的网页在线工具\n官方主页 作者Twitter\n可以用于模型的查看，以及导出gif&#x2F;png图片\n\n制作GIF及帧图简述Chibi-gif\n\n通过导入“新三样”，进行动画选择和缩放等操作，生成序列帧图和生成GIF&#x2F;APNG\n操作流程一、导入文件\n二、调整模型拖动以调整模型位置，更改模型大小，以及边框宽度\n\n三、配置动作组\n四、导出动图\n\n添加装饰部件简述Chibi-deco\n\n通过导入“新三样”，添加自定义的Png贴图，绑定骨骼以实现添加装饰部件\n镜像网站暂时不能生成帧图和GIF\n操作流程一、导入文件同上，将老三样导入\n二、导入装饰部件将想要添加的自定义贴图拖动到Open Deco files的识别区域\n\n三、配置装饰部件\n\n四、导出新三样\n依次点击这四个按钮\n第一个是生成纹理图集，后面三个下载新三样\n注意：下载出来的文件不能直接使用，是因为Atlas文件里的贴图名称会和生成图片的名称不符\n需要将文件名还原，例如：b0037s4_deco.xxx -&gt; b0037s4.xxx\n再导入到相关软件使用\n","categories":["Tutorials"],"tags":["Sdorica","Mobile games","Spine"]},{"title":"Spine动画模型教程-二创教程(二)","url":"/2020/12/26/tutorial/sdorica/spine_anime02/","content":"前面已经详细介绍了模型动画的工具，这次带来的教程是对模型动画的二次创作。\n对游戏角色的部分部位进行修改或添加新部件，以实现一个新模型的创作\n同时希望你看完这篇文章也能加入我们来创造更多有意思的作品\n \n\n\n*申明：\n在此申明，仅作为非商业用途的学习交流和个人记录用途，请严格遵守游戏用户协定，勿将提取的游戏资源发布到任何第三方平台。\n否则将可能造成游戏公司切实的利益损失，与一些不必要的麻烦甚者需承担相应的法律责任\n本篇不授权并禁止任何目的的分享、转载和引用，望理解\n\n介绍前面已经详细介绍了模型动画的工具，这次带来的教程是对模型动画的二次创作。\n对游戏角色的部分部位进行修改或添加新部件，以实现一个新模型的创作\n同时希望你看完这篇文章也能加入我们来创造更多有意思的作品\n举个生动直观的例子如下，看完这篇你也能自行实现这种效果\n\n面具小德 (By 龙龍龖龘)\n纹理图处理就像上面对面具小德的处理一样，我们需要将面具换成海德脸\n那么就需要将部件取下来单独进行处理，然后再完整的打包成一张纹理贴图\n这里我们可以使用一些工具\n使用Spine打开任意版本的Spine，然后选择纹理解包器\n\n选择你要处理角色的.atlas图集配置文件,请确保有同名的Png角色贴图在同一目录下\n例如：h0164s5.atlas.txt/h0164s5.png\n\n查看解包获得到的拆分图集，我们将mask.png面具拿去P图\n\n此处跳过P图过程，将海德面具替换原来的mask.png\n\n再次打开Spine,找到纹理打包器\n\n选定刚才的拆分图的文件夹\n\nSpine为我们重新打包了画框的两个文件，我们把Sdorica_SFT工具生成的文件也复制到这个目录\n\n我们双击使用SkeletonViewer查看模型\n\n值得注意的一点是，我们使用这个方法进行部位修改，可以无需对图片尺寸修改。\n因为是重新打包，所以不需要将图片尺寸修改到和原来一样，但是图像的相对位置要正确\n使用Python脚本码仓工具代码\n按照使用说明操作，可以代替Spine的解包&#x2F;打包功能\n要注意，因为是对原有图集进行打包，而非重新自建打包\n所以你需要在打包之前使用脚本的功能进行图片尺寸的修正\n导出动图Spine使用Spine官方提供的导出支持\n\n你可以选择直接导出gif，也可以选择导出序列帧图\n帧数一般选择25\n\nnaganeko.github.io官方主页 需要代理\n小人模型在线工具\n功能强大\n\n可以预览模型动画(.JSON)\n生成序列帧图并打包\n生成动态图GIF&#x2F;APNG\n向模型额外添加装饰部件\n\n后面会专门写一篇适用于万象物语文章介绍详细功能\nSpineViewerWPF项目地址\n使用的是spine-csharp运行库编写\n\n经过Issue后，作者大佬添加了万象的对应版本可以下载使用\n\n使用说明准备将Assets Studio导出的文件重名为以下后缀的文件：.skel.atlas.png\n导入File -&gt; Open Spine -&gt; 选择文件路径 -&gt; Spine Version 3.2.xx -&gt; open\n选择动作左侧栏-&gt; Attributes -&gt; Anime -&gt; 勾选IsLoop查看\n导出PNG等待想要的帧出现后，点击右上角暂停。然后再点击旁边的小相机选择需要导出的目标路径\n导出GIF点击右上角录像机，等待一会，会弹出选择目标路径\n万象默认选项Spine version: 3.2.xx\n程序崩溃可能会造成崩溃的操作\n\n选择错误的版本\n导出动画\n\nSkeletonExporter项目地址 在release里下载jar包\n使用方法\njava -jar skeletonexporter.jar -i [json配置文件] -d [输出文件夹] --ffmpeg [可执行文件地址(.exe)]\n\n根据json文件将模型动画，导出为.mp4和.png(单帧)\n不推荐使用，参数添加比较复杂，需要ffmpeg\n对万象角色导出的效果一般，角色有描边，剪裁不均，视频是灰底\n\n","categories":["Tutorials"],"tags":["Sdorica","Mobile games","Spine"]},{"title":"Spine动画模型教程-工具详解(一)","url":"/2020/12/25/tutorial/sdorica/spine_anime01/","content":"万象物语模型全工具介绍，看这一篇基本够了(最后更新于: 2021-3-11)\n \n\n\n*申明：\n在此申明，仅作为非商业用途的学习交流和个人记录用途，请严格遵守游戏用户协定，勿将提取的游戏资源发布到任何第三方平台。\n否则将可能造成游戏公司切实的利益损失，与一些不必要的麻烦甚者需承担相应的法律责任\n本篇不授权并禁止任何目的的分享、转载和引用，望理解\n\n介绍万象物语的动画模型采用了Spine3.2.01版本制作，并且解包获取的配置文件是.skel二进制文件\n因其不向下兼容特性，以及很多运行库不支持二进制文件的解读\n所以在尝试了很多工具后，大致总结了下面的概览表\n\n\n\n名称\n别称&#x2F;俗称\n类型&#x2F;版本\n推荐度\n\n\n\nSpine Pro\n骨骼编辑器\n全\n不推荐\n\n\nSpine Trial\n骨骼编辑器\n默认最新版(或破解版)\n不推荐\n\n\nSkeletonViewer\n骨骼预览\n3.5+\n推荐\n\n\nSpine_web_player\n网页播放器\n3.5+\n推荐\n\n\nDragonBonesPro\n龙骨编辑器\n3.1\n失败\n\n\nLive2dViewerEX\nl2dex-spine\n较全(兼容万象)\n推荐\n\n\nUnity\nSpine-unity\n较全(兼容万象)\n不推荐\n\n\nSpineViewerWPF\n-\n较全(兼容万象)\n推荐\n\n\nSuperSpineViewer\n-\n较全(兼容万象)\n推荐\n\n\n阅读本篇可以先查看术语表\nSpine 骨骼动画编辑器推荐指数考虑对于非开发人员的性价比，不推荐\n优点：官方正版，完美导入导出，版本升级和回调；\n缺点：需要购买个人专业版(太贵\n专业版 Pro当下游戏使用最多的动画模型制作软件，例如：万象物语，明日方舟，崩坏系列，少女前线，碧蓝航线等\n非专业开发人士不推荐购买专业版使用\n试用版默认最新版，无法使用\n学习版神秘人提供的破解版，版本固定无法回退\n纹理图打包&#x2F;解包无论哪一种都能使用该功能，当然我也使用Python脚本复刻了该功能用于二创\nSkeletonViewer 骨骼动画播放器推荐指数9.5&#x2F;10 强烈推荐\n介绍使用Java基于spine-libgdx运行库编写，用于快捷预览骨骼动画的播放器，拥有一些简单的功能\nSpine Web Player 网页播放器推荐指数9&#x2F;10 强烈推荐\n介绍使用Typescript基于spine-ts运行库编写，用于多端预览骨骼动画的网页播放器，功能类似SkeletonViewer\nGitee部署因为新版本的js脚本不支持对本地文件的调用，所以需要在服务端部署查看\n如果你有服务器可以直接将“新三样”加生成的html文件放在网页同一目录下使用\n如果没有服务器可以使用Github或者Gitee提供的Page服务部署\n这里我们Gitee为例演示如何快速部署一个网页\n你需要了解Git的简单使用方法\n步骤一、安装git和注册Gitee\n推荐文章\n廖雪峰教程\n二、创建gitee码仓\n名称介绍随意填写，开源设成公开，然后点创建即可\n\n三、将Sdorica_SFT生成的文件移动到一个新建的文件夹\n\n四、使用git上传远程码仓\n该文件夹下右键打开选单，新建一个bash\n\n#如果执行过这个直接跳过git config --global user.name &quot;Your Name&quot;git config --global user.email &quot;email@example.com&quot;#依次执行git initgit add .git commit -m &quot;init.&quot;git remote add origin https://gitee.com/syaoranz/spine_web_player.git #这里替换你自己的码仓地址git push -u origin master\n\n\n五、回到码仓页面进行部署\n\n勾选强制https，然后启动。等待部署完成即可\n\n六、点击部署好的网站查看\n\n大功告成了\nDragonBonesPro 龙骨动画编辑器该方法失败，如果你有更好的想法可以联系作者\n介绍国产白鹭(Egret)科技旗下的制作动画模型的软件，开源免费，提供多平台支持，并且功能多样\n国产游戏使用较多的动画模型软件\n初次尝试安装好后我们尝试导入一下“新三样”\n\n进入选择文件界面，我们要选择.json配置文件，软件会自动匹配到其他两个文件\n注意：新三样的.atlas.txt文件需要去掉后缀.txt，并且名称一致，才能自动识别\n插件选择Spine data,单击完成\n\n我们会发现除了电脑卡了一下，并没有什么反应，多次尝试还是失败了\n更换其他角色部分成功，但是模型无法正常显示\n问题分析推测可能是json配置文件的版本(3.7)和龙骨的插件SDK(3.1)不兼容\n寻找适合的插件或者将配置文件转换成龙骨专用的json文件\n更换插件未找到官方提供的Spine其他版本插件\n手动修改原本的json配置文件尝试修改配置文件\n修改表头会报错无法导入\n删掉动画参数，角色模型仍然是崩的\n所以不再尝试了，感兴趣的朋友可以参考这篇\n使用官方提供得转换工具按照龙骨官方工具文档操作，先安装NodeJs，然后安装工具\n新建一个命令行窗口输入2db --help 查看环境是否安装上了\n\n在新三样的目录下，我们先把原先的json文件复制到一个新建的文件夹，然后在新的里面使用命令\n等待了相当长的时间，因为见不到报错和运行日志所以我放弃了\n\n失败告终尝试了各种方法，均不能完美导入。\n现在只能等待龙骨推出支持的Spine版本了\n\nLive2dViewerEX(DLC-Spine) 桌宠壁纸软件推荐指数10&#x2F;10\n介绍由C语言基于Spine-c运行库编写的拓展插件，支持对spine动画的读取，预览，自定义动作组等功能\nsteam商店链接(本体+拓展&#x3D;26+9&#x3D;35 CNY)\n这款软件是我觉得最适合想自己玩赏角色模型的玩家使用的，优点实在太多了，简单说几点\n\n无需任何操作处理，可以直接将解包得到的“老三样”导入并预览\n支持自定义动作组，点击触摸触发动作或文字弹框\n无上手难度，不需要编程基础\n可以把自己编辑的模型当桌宠，也可以上传至创意工坊\n\n缺点是付费，暂不支持网页版（询问后得知有测试版WebGL)\n\n教程官方教学视频\nSuperSpineViewer介绍Java编写的基于Spine-libgdx运行库，界面简洁，功能多样\n支持导出序列帧图以及视频(需要ffmpeg环境支持)\n推荐指数推荐\n教程：https://www.taptap.com/topic/16434701\n码仓地址: https://github.com/Aloento/SuperSpineViewer\nSpineViewerWPF介绍有Java编写的基于Spine-C#运行库编写，功能全面，支持导出动图和视频\n需要注意安装依赖运行\n推荐指数推荐\n项目地址: https://github.com/kiletw/SpineViewerWPF\nSpine-Unity 运行库介绍因为游戏就是Unity引擎开发的，所以是肯定支持的\n但由于要下载的运行库文件太大，所以我没有亲自尝试\n官方中文文档\n推荐指数不推荐\n术语骨骼动画 Spine释义骨骼，常见的动画模型编辑软件。模型具有互相连接的“骨骼”组成的骨架结构，通过改变骨骼的朝向和位置来为模型生成动画。\n版本回退&#x2F;升级 Rollback&#x2F;Upgrade回退：将最新版本的配置文件降低到低版本，例如：4.0 -&gt; 3.7 or 2.1\n升级：\nSpine的配置文件没有向下兼容的特性\n所以只能使用专业版或者自己编写脚本将低版本的配置文件转换成高版本\n例如：3.2 -&gt; 3.7\n模型配置文件Json格式文件：模型的总体配置文件，控制模型的贴图，皮肤，插槽，动画等\nSkel二进制文件：同json格式文件，但被特殊处理成二进制文件以减少占用的内存\nAtlas文件： 贴图的配置文件，根据它可将贴图拆分下来\n运行库 Runtime不同语言设计的程序运行时动态调用的属性、类、方法等\n贴图&#x2F;纹理图 AtlasSpine模型的贴片图，俗称”碎尸图”\n小人模型 chibi对Spine动画模型的俗称\n老三样&#x2F;新三样老三样就是通过解包获得的三个源文件\n.skel.bytes/.atlas.txt/.png\n\n新三样就是通过转换新获得的三个模型文件\n.json/.atlas.txt/.png\n\n序列帧序列帧是把活动视频用一帧一帧的图像文件来表示\n常见的动画帧数设置为25、30FPS\n即: 每秒25(30)张图片\n","categories":["Tutorials"],"tags":["Sdorica","Mobile games","Spine"]},{"title":"从零开始的手游解包教程-小人模型篇(三)","url":"/2020/12/24/tutorial/sdorica/gamedata_reverse03/","content":"看了前面两篇文章，相信你已经能很熟练的使用AssetStudio进行资源包的解包这次将介绍的是对万象物语小人模型的拆包和预览\n \n\n\n*申明：\n在此申明，仅作为非商业用途的学习交流和个人记录用途，请严格遵守游戏用户协定，勿将提取的游戏资源发布到任何第三方平台。\n否则将可能造成游戏公司切实的利益损失，与一些不必要的麻烦甚者需承担相应的法律责任\n本篇不授权并禁止任何目的的分享、转载和引用，望理解\n\n介绍看了前面两篇文章，相信你已经能很熟练的使用AssetStudio进行资源包的解包\n这次将介绍的是对万象小人模型的拆包和预览\n本篇将直接介绍如何使用工具操作和预览，不需要使用到编程\n准备工作*注：本教程所用工具可加群获取\nPC电脑(Win10)\nAssetStudioSdorica_SFT工具\n\n简单介绍万象物语角色模型都使用的是Spine骨骼动画制作，以下简称小人模型\n典型的特征就是需要三个文件来装配一个模型\n\n\n\n名称\n文件拓展名\n简介\n\n\n\n配置文件\n.skel &#x2F;.skel.bytes&#x2F;.json\n小人模型动画的配置文件\n\n\n纹理图集\n.atlas &#x2F; .atlas.txt\n小人模型贴图的配置图集\n\n\n贴图\n. png\n小人模型贴图\n\n\n本篇为了区分源文件和处理后的文件使用“老三样”和”新三样“来区分\n使用方法一、解包模型资源使用AS对这两个文件分别解包\n\n这里我们全部导出，分别得到两个文件夹，我们把他移动到工作目录\n\n这里我们以h0030s5_a2为例，将这两个文件里的”老三样”移动到一个新的目录\n\n二、使用Sdorica_SFT工具我们得到的源文件是为游戏运行准备的，为了减少占用的内存它们都被处理过\n例如：图片尺寸会被缩小，配置文件采用二进制存储\n这里我们要将它们转换成运行库兼容的格式\n将压缩包解压，双击启动Sdorica_SFT.exe\n稍等半分钟加载，然后输入暗号\n\n\n按照提示依次将刚才的三个文件拖入到窗口，程序会自动处理\n\n我们可以看到在源文件的路径下生成了h0030s5_a2.json配置文件和index.html网页(本篇不用)\n\n三、预览模型首先确保你的电脑配置了Java运行环境(JRE 8+)或者Java开发环境(JDK)\nWin+R打开运行，输入cmd，新建一个命令行窗口，输入以下命令查看是否安装\njava --version\n\n\n如果电脑没有安装环境，你可以到java官网下载\n安装完成后再用上面的方法检测下是否有了环境变量\n\n我们可以接着刚才没完成的操作，在对话窗口中输入”y”\n就会调用SkeletonViewer播放器查看模型\n\n如果想下次再用这个播放器,使用CMD在命令行输入以下命令即可\njava -jar skeletonViewer.jar\n","categories":["Tutorials"],"tags":["Sdorica","Mobile games","Reverse engineering"]},{"title":"从零开始的手游解包教程-编码解码篇(二)","url":"/2020/12/23/tutorial/sdorica/gamedata_reverse02/","content":"本篇主要介绍如何将AssetStudio导出的部分数据文件进行解码，将它从”乱码”格式转换成易于阅读的格式将从剧情中角色台词文本入手，介绍几种常见的数据类型和编码方式\n \n\n\n*申明：\n在此申明，仅作为非商业用途的学习交流和个人记录用途，请严格遵守游戏用户协定，勿将提取的游戏资源发布到任何第三方平台。\n否则将可能造成游戏公司切实的利益损失，与一些不必要的麻烦甚者需承担相应的法律责任\n本篇不授权并禁止任何目的的分享、转载和引用，望理解\n\n介绍本篇主要介绍如何将AssetStudio导出的部分数据文件进行解码，将它从”乱码”格式转换成易于阅读的格式\n将从剧情中角色台词文本入手，介绍几种常见的数据类型和编码方式\n难度适中，无需系统的学习过计算机编程但需要你对Python语言有较基础的认知\n准备工作PC电脑：\n推荐Win10\n语言：\nPython3.7以上\n自行安装和配置环境变量\n代码编辑器IDE:\n微软 VSCode (本篇推荐，具体安装方法网上有详细教学)\n当然记事本(硬核老哥)也行\n数据格式及Unicode编码介绍Json数据格式一种轻量级的数据交换格式，Js对象简谱，类似Python中的字典\n其特征是键值对，并且独立文件不可注释\n可以充当配置文件，可以作为简易数据库，也是最常见的Http数据传输类型\n同时也是万象物语用于存储数据最常用的格式\n形如\n&quot;Sdorica&quot; = &#123;        &quot;键&quot;: &quot;值&quot;,    \t&quot;普吉&quot; : &quot;牛角面包&quot;,        .....    &#125;\n\nUnicode编码学过计算的朋友都应该了解，俗称”统一码”。最常见的规则便是utf-8\n基本上有中文的地方就会出现这种格式，将中文编码成计算机喜欢的utf-8格式也是节约内存的手段\n例如\n\\u666e\\u5409\n\n就是”普吉“经过编码后的\n实战使用一、解包元数据我们还是使用AssetStudio进行解包具体方法参考上篇\n\n预览一下文件\n\n导出一个作为示例，这里导出了main_001_004_dialog_chinesesimplified\n\n二、编码预览我们用编辑器打开预览，复制一段Unicode去解码一下看看\n\n这里我们使用了常用的在线解码网站CyberChef进行解码\n\\\\u4e3a\\\\u4ec0\\\\u4e48\\\\u7a77\\\\u8ffd\\\\u4e0d\\\\u820d\\\\uff1f\\\n\n得到结果(多余的斜杠不影响，是因为需要对&quot;\\&quot;等特殊字符转义\n\\为\\什\\么\\穷\\追\\不\\舍\\？\\\n\n\n三、使用Python脚本转换这里就直接贴出代码，就是对Json库的基本运用，这里就不过多讲解了\n#-*- coding: utf-8 -*-# Author: Syaoran# ClassName: Sdorica Dialogue Json Beautifyimport jsonimport sysfile_path = sys.argv[1]data = json.load(open(file_path,&#x27;r&#x27;,encoding=&#x27;utf-8&#x27;))name = data.get(&#x27;m_Name&#x27;)meta = data.get(&#x27;_serializedStateValues&#x27;)[0]dialogue = json.loads(meta.replace(&#x27;:.&#x27;,&#x27;:0.&#x27;))dialogue_ls = []for item in dialogue[&#x27;$content&#x27;]:    speaker = item.get(&#x27;SpeakerName&#x27;)    text = item.get(&#x27;Text&#x27;)    dialogue_ls.append(speaker+&#x27;\\n&#x27;+text)dst_path = name + &#x27;_beautify.txt&#x27;with open(dst_path,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;) as f:    f.write(name+&#x27;\\n\\n&#x27;)    f.write(&#x27;\\n\\n&#x27;.join(dialogue_ls))    f.close()\n\n将代码复制粘贴保存成Sdorica_DJB.py，然后在文件地址栏输入cmd然后回车，进入命令行\n\n紧接着输入 python Sdorica_DJB.py 然后将main_001_004_dialog_chinesesimplified文件拖入，然后回车即可\n或者直接用 python Sdorica_DJB.py main_001_004_dialog_chinesesimplified.json回车，也是可以的\n\n成功得到了生成的文本文件，打开查看一下\n\n\n","categories":["Tutorials"],"tags":["Sdorica","Mobile games","Reverse engineering"]},{"title":"从零开始的手游解包教程-基础入门篇(一)","url":"/2020/12/22/tutorial/sdorica/gamedata_reverse01/","content":"从零开始的拆包教程，主要介绍如何从游戏资源包(.ab文件)中提取想要的信息。例如：立绘，角色头像，剧情文本\n \n\n\n*申明：\n在此申明，仅作为非商业用途的学习交流和个人记录用途，请严格遵守游戏用户协定，勿将提取的游戏资源发布到任何第三方平台。\n否则将可能造成游戏公司切实的利益损失，与一些不必要的麻烦甚者需承担相应的法律责任\n本篇不授权并禁止任何目的的分享、转载和引用，望理解\n\n介绍从零开始的拆包教程，主要介绍如何从游戏资源包(.ab文件)中提取想要的信息。\n例如：立绘，角色头像，剧情文本\n本篇将从较为简单的立绘图片入手，提供保姆级别的教程。\n上手难度几乎没有，据小狼说连普吉都能学会\n准备工作PC电脑 （推荐Win10)\n游戏资源包\n文件路径(安卓)：\nAndroid/data/com.ilongyuan.sdorica.longyuan/files/AssetBundles/\n\n将文件夹用解压工具打包传输至电脑\n解包软件：AssetStudio\n操作流程一、准备工作不过多赘述了，没有操作难度\n确保你已经安装好了上述的软件，并且将资源包解压到你想要的工作目录\n二、熟悉软件解压后目录找到AssetStudioGUI.exe\n\n双击打开软件软件由C语言编写，官方版暂无中文支持。\n不过对于万象物语我们不需要任何配置，直接使用默认的配置即可\n\n导入资产文件夹左上角依次 File -&gt; Load folder -&gt; 选择界面\n\n找到之前解压好的资产文件夹\n\n1.使用右上角的搜索功能，输入角色的资产编号，普吉：b0037\n2.单机标注类型的文件夹\n3.然后点击按钮选择文件夹\n*注意: 请确保不要未选定就直接点击，这样会导入一整个资产文件夹，并导致软件卡死，电脑爆炸(并不)\n\n三、使用软件预览出现下面这个读条和日志，就表示你已经成功导入了\n\n点击子栏的 Asset List,会发现被封包的源文件\n\n单击其中一个预览试试\n哇！鲜嫩的牛角面包出现了，快捕获它下锅！\n\n四、导出文件\n选择性导出：单选或者使用Ctrl+鼠标左键选择 -&gt; Export -&gt; Selected assets\n导出全部：Export -&gt; All assets\n弹出目标文件夹的选择框，选择你想要存放的文件夹\n默认是源文件的文件夹，导出后会自动打开目标文件夹\n五、查看成果至此我们已经成功地将普吉的所有立绘图片导出了(流口水\n\n\n其他文件用法参考类型，方法类似\n其他部分游戏也适用该教程，例如明日方舟，碧蓝航线，少女前线\n总结总体来说没有什么难度，该软件上手简单，简洁实用\n美中不足的是不能批量导入，如果误将整个AssetBundles导入会使内存卡死\n并且导出自定的目标文件夹地址后，下次导入文件会是该位置，而非原资源文件夹，再次选择非常麻烦\n注释资产编号资产编号(AssetsId)程序员为简便的区分角色名称使用了形如x0000的这种编号；\n琉：h0030 普吉：b0037\n这个后续会专门出文章介绍，这里你可以先自己尝试一下\n类型介绍几个常用的类型\n\n\n\n特征名称\n简介\n备注\n\n\n\ncharacter_image\n魂册图片\n简单,可预览\n\n\ncharacter_largeimage\n角色立绘\n简单,可预览\n\n\naudioclip_sfx\n角色语音音效\n简单,可预览\n\n\ncutscene_char\n角色故事台词\n中等，需要编码处理\n\n\ncharacter_model\n角色配置文件\n中等，需要编码处理, JSON格式，不易读\n\n\ncharacter_spine_skeleton\n角色骨骼动画二进制文件\n较难，模型动画配置文件\n\n\ncharacter_spine_texture\n角色骨骼动画图集\n较难，模型动画图集文件\n\n\ncharacter_prefab\n角色模型预制文件\n较难，Unity生成的配置文件\n\n\nvfx_prefab\n特效预制文件\n较难，Unity生成的配置文件\n\n\n","categories":["Tutorials"],"tags":["Sdorica","Mobile games","Reverse engineering"]},{"title":"Hello World","url":"/2020/06/01/notes/hello-world/","content":"Welcome to My Blog! \nHello, World!\n\n","categories":["Notes"],"tags":["Small talk"]}]